!function(e){function n(o){if(a[o])return a[o].exports;var t=a[o]={exports:{},id:o,loaded:!1};return e[o].call(t.exports,t,t.exports,n),t.loaded=!0,t.exports}var a={};return n.m=e,n.c=a,n.p="",n(0)}([function(e,n,a){function o(e,n,a){const o=a.createShader(n);if(a.shaderSource(o,e),a.compileShader(o),!a.getShaderParameter(o,a.COMPILE_STATUS))throw"Shader compile failed with: "+a.getShaderInfoLog(o);return o}function t(e,n,a){const o=a.getUniformLocation(e,n);if(o===-1)throw"Can not find uniform "+n+".";return o}function i(e,n,a){const o=a.getAttribLocation(e,n);if(o===-1)throw"Can not find attribute "+n+".";return o}function r(e,n,a){var o=e.createProgram();e.attachShader(o,n),e.attachShader(o,a),e.linkProgram(o),e.useProgram(o);var t=new Float32Array([-1,1,-1,-1,1,1,1,-1]),r=e.createBuffer();e.bindBuffer(e.ARRAY_BUFFER,r),e.bufferData(e.ARRAY_BUFFER,t,e.STATIC_DRAW);var c=i(o,"position",e);return e.enableVertexAttribArray(c),e.vertexAttribPointer(c,2,e.FLOAT,e.FALSE,8,0),o}function c(e,n,a,t,i){var c="#define NUMBER_OF_ITERATIONS "+a+"\n";c+="#define FRAC_EXPRESSION "+i+"\n","mandelbrot full"==t?(c+="#define FRACTAL_FUNC mandelbrot\n",c+="#define SHOW_PREVIEW\n",c+="#define ZOOMABLE 0\n"):"mandelbrot zoom"==t?(c+="#define FRACTAL_FUNC mandelbrot\n",c+="#define ZOOMABLE 1\n"):"julia"==t&&(c+="#define FRACTAL_FUNC julia\n",c+="#define ZOOMABLE 0\n");var l=o(c+d,e.FRAGMENT_SHADER,e);return r(e,n,l)}function l(e,n){s=c(p,N,e,"julia",n),v=c(b,I,e,"mandelbrot full",n),h=c(R,x,e,"mandelbrot zoom",n)}function u(e){var n=(e.offsetX/B.canvas_width_full*2-1)*B.frame_radius_full,a=(e.offsetY/B.canvas_height_full*2-1)*B.frame_radius_full;B.c_real=n,B.c_imag=a,O.value=B.c_real,M.value=B.c_imag}function m(e){var n=2*-(e.movementX/B.canvas_width_zoom)*B.frame_radius_zoom,a=2*-(e.movementY/B.canvas_height_zoom)*B.frame_radius_zoom;B.c_real+=n,B.c_imag+=a,O.value=B.c_real,M.value=B.c_imag}function f(){if(y.checked){var e=1.2*Date.now();B.c_real=-.79+Math.sin(e/2e3)/40,B.c_imag=.2121+Math.cos(e/1330)/40,O.value=B.c_real,M.value=B.c_imag}[[p,s],[b,v],[R,h]].forEach(function(e,n){var a=e[0],o=e[1];a.viewport(0,0,B.width,B.height);var i=new Float32Array(8);i[0]=B.width,i[1]=B.height,i[2]=Number(B.c_real),i[3]=Number(B.c_imag),i[4]=B.c_real-B.frame_radius_zoom,i[5]=B.c_real+B.frame_radius_zoom,i[6]=B.c_imag-B.frame_radius_zoom,i[7]=B.c_imag+B.frame_radius_zoom;var r=t(o,"data",a);a.uniform1fv(r,i),a.drawArrays(a.TRIANGLE_STRIP,0,4)}),C.checked&&requestAnimationFrame(f)}var d=a(1),_="attribute vec2 position;\nvoid main() { gl_Position = vec4(position, 0.0, 1.0); }";fractal_type={NORMAL:"cadd(cmul(z,z), c)",INV_MU:"cadd(cmul(z,z), cdiv(complex(1.0,0.0), c))"};var s,v,h,g=document.getElementById("canvas_mandelbrot_full"),A=document.getElementById("canvas_mandelbrot_zoom"),E=document.getElementById("canvas_julia"),b=g.getContext("webgl"),R=A.getContext("webgl"),p=E.getContext("webgl"),I=o(_,p.VERTEX_SHADER,b),x=o(_,p.VERTEX_SHADER,R),N=o(_,p.VERTEX_SHADER,p),w=document.getElementById("res_x"),S=document.getElementById("res_y"),T=document.getElementById("iterations"),y=document.getElementById("fractal_julia_animated"),O=document.getElementById("c_real"),M=document.getElementById("c_imag"),C=document.getElementById("render_running"),z=document.getElementById("formula_normal"),F=document.getElementById("formula_inverse_mu"),B={width:Number(w.value),height:Number(S.value),formula:fractal_type.NORMAL,iterations:Number(T.value),c_real:Number(O.value),c_imag:Number(M.value),canvas_width_full:Number(g.width),canvas_height_full:Number(g.height),canvas_width_zoom:Number(A.width),canvas_height_zoom:Number(A.height),frame_radius_full:2,frame_radius_zoom:.125,fractal_type:"julia",do_animation:!1};l(B.iterations,B.formula),w.onkeyup=function(){E.width=Number(w.value),g.width=Number(w.value),A.width=Number(w.value),B.width=Number(w.value)},S.onkeyup=function(){E.height=Number(S.value),g.height=Number(S.value),A.height=Number(S.value),B.height=Number(S.value)},T.onkeyup=function(){B.iterations=Number(T.value),l(B.iterations)},O.onkeyup=function(){B.c_real=Number(O.value)},M.onkeyup=function(){B.c_imag=Number(M.value)},z.onclick=function(){B.formula=fractal_type.NORMAL,l(B.iterations,B.formula)},F.onclick=function(){B.formula=fractal_type.INV_MU,l(B.iterations,B.formula)};var X=!1,P=!1;g.onmousedown=function(e){e.preventDefault(),X=!0},A.onmousedown=function(e){e.preventDefault(),P=!0},window.onmouseup=function(e){X=!1,P=!1},window.onmousemove=function(e){X&&u(e),P&&m(e)},g.onwheel=function(e){e.preventDefault(),e.deltaY>0?B.frame_radius_zoom*=1.1:B.frame_radius_zoom/=1.1},A.onwheel=g.onwheel,requestAnimationFrame(f),C.onclick=function(){C.checked&&requestAnimationFrame(f)};var L=Math.floor(window.innerWidth/3);B.width=L,B.height=L,w.value=L,S.value=L,B.canvas_height_full=L,B.canvas_width_full=L,B.canvas_height_zoom=L,B.canvas_width_zoom=L,[E,g,A].forEach(function(e,n){e.width=L,e.height=L})},function(e,n){e.exports="// fractal.glsl\n\n#ifndef NUMBER_OF_ITERATIONS\n#define NUMBER_OF_ITERATIONS 1024\n#endif\n\n#ifndef FRACTAL_FUNC\n#define FRACTAL_FUNC mandelbrot\n#endif\n\n#ifndef ZOOMABLE\n#define ZOOMABLE 0\n#endif\n\n#ifndef CROSSHAIR_WIDTH\n#define CROSSHAIR_WIDTH 0.002\n#endif\n\n#ifndef FRAC_EXPRESSION\n#define FRAC_EXPRESSION cadd(cmul(z,z), c)\n#endif\n\nprecision highp float;\n\n/*\nwidth.\nheight\n\nc_real\nc_imag\n\nx min\nx max\ny min\ny max\n*/\nuniform float data[8];\n\nfloat WIDTH  = data[0];\nfloat HEIGHT = data[1];\nfloat C_REAL = data[2];\nfloat C_IMAG = data[3];\nfloat X_MIN  = data[4];\nfloat X_MAX  = data[5];\nfloat Y_MIN  = data[6];\nfloat Y_MAX  = data[7];\n\nconst int MAX_ITERATIONS = NUMBER_OF_ITERATIONS;\n\nvec2 iResolution = vec2(WIDTH, HEIGHT);\n\nstruct complex {\n    float r;\n    float i;\n};\n\ncomplex cadd(complex a, complex b) { return complex(a.r + b.r, a.i + b.i); }\ncomplex csub(complex a, complex b) { return complex(a.r - b.r, a.i - b.i); }\ncomplex cmul(complex a, complex b) { return complex(a.r*b.r - a.i*b.i, a.i*b.r + a.r*b.i); }\nfloat cmag2(complex a) { return a.r * a.r + a.i * a.i; }\ncomplex cdiv(complex a, complex b) {\n    float denom = cmag2(b);\n    return complex((a.r*b.r + a.i*b.i)/denom, (a.i*b.r + a.r*b.i)/denom);\n}\n\nfloat fractal(complex c, complex z) {\n    for (int iteration = 0; iteration < MAX_ITERATIONS; iteration++) {\n        z = FRAC_EXPRESSION;\n        if (cmag2(z) > float(NUMBER_OF_ITERATIONS)) {\n            float sl = float(iteration) - log2(log2(z.r * z.r + z.i * z.i)) + 4.0;\n            return sl;\n        }\n    }\n    return 0.0;\n}\n\nfloat mandelbrot(vec2 coordinate, vec2 offset) {\n    complex c = complex(coordinate.x, coordinate.y);\n    complex z = complex(0.0, 0.0);\n\n    return fractal(c, z);\n}\n\nfloat julia(vec2 coordinate, vec2 offset) {\n    complex c = complex(offset.x, offset.y);\n    complex z = complex(coordinate.x, coordinate.y);\n\n    return fractal(c, z);\n}\n\nvec2 fragCoordToXY(vec4 fragCoord) {\n    vec2 relativePosition = fragCoord.xy / iResolution.xy;\n#if ZOOMABLE\n    float aspectRatio = iResolution.x / HEIGHT;\n\n    vec2 center = vec2((X_MAX + X_MIN) / 2.0, (Y_MAX + Y_MIN) / 2.0);\n\n    vec2 cartesianPosition = (relativePosition - 0.5) * (X_MAX - X_MIN);\n    cartesianPosition.x += center.x;\n    cartesianPosition.y -= center.y;\n    cartesianPosition.x *= aspectRatio;\n    return cartesianPosition;\n#else\n    return relativePosition * 4.0 - 2.0;\n#endif\n}\n\nvoid main() {\n\n    vec2 coordinate = fragCoordToXY(gl_FragCoord);\n    float fractalValue = FRACTAL_FUNC(coordinate, vec2(C_REAL, C_IMAG));\n    vec3 color = 0.5 + 0.5*cos( 3.0 + fractalValue*0.15 + vec3(0.0,0.6,1.0));\n\n#ifdef SHOW_PREVIEW\n    // show preview of the zoomable window\n    if (coordinate.x >= X_MIN && coordinate.x <= X_MAX &&\n        coordinate.y <= -Y_MIN && coordinate.y >= -Y_MAX) {\n        color = 1.0 - color;\n    }\n#endif\n\n#if ZOOMABLE\n    vec2 relativePosition = gl_FragCoord.xy / iResolution.xy -  0.5;\n    if (((abs(relativePosition.x) < CROSSHAIR_WIDTH) ||(abs(relativePosition.y) < CROSSHAIR_WIDTH))\n        && dot(relativePosition, relativePosition) < 0.0025) {\n        color = 1.0 - color;\n    }\n#endif\n\n    gl_FragColor = vec4(color, 1.0);\n}\n"}]);